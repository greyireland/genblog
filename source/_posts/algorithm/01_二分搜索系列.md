---
title: 01_二分搜索系列
tags:
  - algorithm
  - 二分搜索
categories:
  - algorithm
date: 2019-02-23 20:58:30
---

# 二分搜索模板
### 题目
给一个有序数组和目标值，找第一次/最后一次/任何一次出现的索引，如果没有出现返回-1

通用模板
四点要素:
1. start + 1 < end
2. start + (end - start) / 2 
3. A[mid] ==, <, >
4. A[start] A[end] ? target


```go
标准代码：
func search(nums []int, target int) int {
    start:=0
    end:=len(nums)-1
    for(start+1<end){
        mid:=start+(end-start)/2
        if nums[mid]==target{
            end=mid
        }else if nums[mid]<target{
            start=mid
        }else if nums[mid]>target{
            end=mid
        }
    }
    if nums[start]==target{
        return start
    }
    if nums[end]==target{
        return end
    }
    return -1
}
```
大部分二分查找类的题目都可以用这个模板，然后做一点特殊逻辑即可


### 常见题目：
1. 二分查找
```go
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。

示例 1:
输入: [1,3,5,6], 5
输出: 2

示例 2:
输入: [1,3,5,6], 2
输出: 1

示例 3:
输入: [1,3,5,6], 7
输出: 4

示例 4:
输入: [1,3,5,6], 0
输出: 0

解答：
- 二分查找
- 判断首尾的情况，找first position +1，判断end

func searchInsert(nums []int, target int) int {
    if len(nums)==0{
        return 0
    }
    start:=0
    end:=len(nums)-1
    for(start+1<end){
        mid:=start+(end-start)/2
        if nums[mid]>target{
            end=mid
        }else if nums[mid]<target{
            start=mid
        }else if nums[mid]==target {
            end=mid
        }
    }
    if nums[start]>=target{
        return start
    }else if nums[end]<target{
        return end+1
    }
    return start+1
}
```

2. 矩阵搜索
```go
编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。

示例 1:
输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
输出: true

示例 2:
输入:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
输出: false

//从右上角开始查找log(m)+log(n)
func searchMatrix(matrix [][]int, target int) bool {
    if len(matrix)==0||len(matrix[0])==0{
        return false
    }
    i:=len(matrix)-1
    j:=0
    for(i>=0&&j<len(matrix[0])){
        if matrix[i][j]<target{
            j++
        }else if matrix[i][j]>target{
            i--
        }else{
            return true
        }
    }
    
    return false
}
```

3. 旋转数组搜索


核心思路：

根据nums[start]<nums[mid] 判断两种情况

```go
假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。

示例 1:
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4

示例 2:
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1


func search(nums []int, target int) int {
    if len(nums)==0{
        return -1
    }
    start:=0
    end:=len(nums)-1
    for(start+1<end){
        mid:=start+(end-start)/2
        if nums[start]<nums[mid]{
            if target>=nums[start]&&target<=nums[mid]{
                end=mid
            }else{
                start=mid
            }
            
        }else if nums[start]>nums[mid]{
            if nums[mid]<=target&&target<=nums[end]{
                start=mid
            }else{
                end=mid
            }
            
        }else if nums[mid]==target{
            return mid
        }
    }
    if nums[start]==target{
        return start
    }else if nums[end]==target{
        return end
    }
    
    return -1
}

存在重复元素情况，只能线性判断
func search(nums []int, target int) bool {
    for i:=0;i<len(nums);i++{
        if nums[i]==target{
            return true
        }
    }
    return false
}
```


### 总结
- 每一个模板都是前人总结的经验。
- 没有模板就自己创造一个模板。