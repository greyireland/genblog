---
title: 00_算法入门【算法模板】
tags:
  - algorithm
  - strStr
  - subset
categories:
  - algorithm
date: 2019-02-23 19:43:31
---

## 算法理解
算法理解：

就是找一套解决问题的模板，有特殊情况就做特殊处理

类似【算法模板】【算法设计模式】

后续文章会依次介绍各种算法的模板，关注[github](https://github.com/greyireland)

## 模板入门

### 1. 双重循环模板【strStr】
常见面试题，实现双重循环就OK【strStr在面试中了解KMP算法即可】

双重for循环模板：
- 参数检查
- 双重循环
- 逻辑判断&边界检查


```go
问题：
实现 strStr() 函数。
给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中
找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:
输入: haystack = "hello", needle = "ll"
输出: 2

示例 2:
输入: haystack = "aaaaa", needle = "bba"
输出: -1

代码实现：
func strStr(haystack string, needle string) int {
    if needle==""{
        return 0
    }
    var i,j int;
    for i=0;i<len(haystack)-len(needle)+1;i++{
        for j=0;j<len(needle);j++{
            if haystack[i+j]!=needle[j]{
                break
            }
        }
        if j==len(needle){
            return i
        }
    }
    return -1
}
```

### 2. 回溯法模板【subset/subset2】
```go
# 回溯法backtrack通用模板

func subsets(nums []int) [][]int {
    var res = make([][]int, 0)
    var tmp = make([]int, 0)
    backtrack(&res, tmp, nums, 0)
 
    return res
}
//res 所有子集的结果
//tmp 临时子集
//nums 原始数组
//start 下次开始取数据的位置
func backtrack(res *[][]int, tmp []int, nums []int, start int) {
    //golang必须是用copy，因为tmp的数据可能变化
    var e = make([]int, len(tmp))
    copy(e, tmp)
    *res = append(*res, e)

    for i := start; i < len(nums); i++ {
        tmp = append(tmp, nums[i])
        backtrack(res, tmp, nums, i+1)
        tmp = tmp[:len(tmp)-1]
    }
}
```



subset
```go
给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

解答：
func subsets(nums []int) [][]int {
    var res = make([][]int, 0)
    var tmp = make([]int, 0)
    backtrack(&res, tmp, nums, 0)
 
    return res
}
//res 所有子集的结果
//tmp 临时子集
//nums 原始数组
//start 下次开始取数据的位置
func backtrack(res *[][]int, tmp []int, nums []int, start int) {
    //golang必须是用copy，因为tmp的数据可能变化
    var e = make([]int, len(tmp))
    copy(e, tmp)
    *res = append(*res, e)

    for i := start; i < len(nums); i++ {
        tmp = append(tmp, nums[i])
        backtrack(res, tmp, nums, i+1)
        tmp = tmp[:len(tmp)-1]
    }
}
```


subset 2
```go
给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。

示例:
输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
解答：
func subsetsWithDup(nums []int) [][]int {
    var res = make([][]int, 0)
    var tmp = make([]int, 0)
    sort.Ints(nums) //先排序
    backtrack(&res, tmp, nums, 0)
    return res
}

func backtrack(res *[][]int, tmp []int, nums []int, start int) {
    //golang必须是用copy，因为tmp的数据可能变化
    var e = make([]int, len(tmp))
    copy(e, tmp)
    *res = append(*res, e)

    for i := start; i < len(nums); i++ {
        //判断符合条件才进行回溯
        if i == start || nums[i] != nums[i-1] {
            tmp = append(tmp, nums[i])
            backtrack(res, tmp, nums, i+1)
            tmp = tmp[:len(tmp)-1]
        }
        
    }
}

```


## QA?
### 算法面试注意点？
1. 找到各类问题的通用模板，根据题目特殊情况做特殊处理即可。
2. 先去朝一个解决问题的方向！先去抛出可行解，而不是最优解！先解决，再优化！
3. 代码的风格要统一！熟悉各类语言的代码规范
4. 最常见错误：A.访问下标时，不能访问越界！B.空值问题run time error!